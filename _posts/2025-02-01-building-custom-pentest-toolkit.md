---
layout: post
title: "Building Your Custom Penetration Testing Toolkit"
date: 2025-02-01 14:30:00 -0000
categories: [Tools, Tutorial]
tags: [penetration testing, automation, python, tools]
author: Your Name
reading_time: 20
---

## Introduction

Every penetration tester needs a reliable toolkit. While tools like Metasploit, Burp Suite, and Nmap are essential, creating custom tools tailored to your workflow can significantly improve efficiency and effectiveness.

In this guide, I'll walk you through building a modular penetration testing toolkit in Python.

## Why Build Custom Tools?

### Advantages:
- ✅ **Customization**: Tailored to your specific needs
- ✅ **Learning**: Deep understanding of underlying techniques
- ✅ **Flexibility**: Easy to modify and extend
- ✅ **Integration**: Seamless workflow automation
- ✅ **Stealth**: Less likely to trigger signatures

### When to Build Custom:
- Repetitive tasks that need automation
- Specific edge cases not covered by existing tools
- Integration between multiple tools
- Learning and skill development

---

## Toolkit Architecture

Our toolkit will have a modular structure:
```
pentest-toolkit/
├── core/
│   ├── __init__.py
│   ├── network.py
│   ├── web.py
│   └── exploit.py
├── modules/
│   ├── recon/
│   ├── scanning/
│   ├── exploitation/
│   └── post_exploitation/
├── utils/
│   ├── logger.py
│   ├── reporter.py
│   └── config.py
├── config/
│   └── settings.json
└── main.py
```

---

## Core Components

### 1. Network Scanner Module
```python
# core/network.py
import socket
import concurrent.futures
from typing import List, Tuple

class NetworkScanner:
    def __init__(self, timeout=1, threads=100):
        self.timeout = timeout
        self.threads = threads
    
    def scan_port(self, host: str, port: int) -> Tuple[int, bool]:
        """Scan a single port"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            result = sock.connect_ex((host, port))
            sock.close()
            return (port, result == 0)
        except Exception as e:
            return (port, False)
    
    def scan_ports(self, host: str, ports: List[int]) -> dict:
        """Scan multiple ports using threading"""
        open_ports = []
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.threads) as executor:
            futures = {executor.submit(self.scan_port, host, port): port 
                      for port in ports}
            
            for future in concurrent.futures.as_completed(futures):
                port, is_open = future.result()
                if is_open:
                    open_ports.append(port)
        
        return {
            'host': host,
            'open_ports': sorted(open_ports),
            'total_scanned': len(ports)
        }
    
    def detect_service(self, host: str, port: int) -> str:
        """Basic service detection"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            sock.connect((host, port))
            sock.send(b'HEAD / HTTP/1.0\r\n\r\n')
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            sock.close()
            return banner.split('\n')[0] if banner else "Unknown"
        except:
            return "Unknown"

# Usage example
if __name__ == "__main__":
    scanner = NetworkScanner()
    results = scanner.scan_ports("192.168.1.1", range(1, 1001))
    print(f"Found {len(results['open_ports'])} open ports")
```

### 2. Web Vulnerability Scanner
```python
# core/web.py
import requests
from urllib.parse import urljoin, urlparse
from bs4 import BeautifulSoup

class WebScanner:
    def __init__(self, target_url, timeout=10):
        self.target_url = target_url
        self.timeout = timeout
        self.session = requests.Session()
        self.visited_urls = set()
    
    def crawl(self, url, max_depth=2, current_depth=0):
        """Crawl website and discover URLs"""
        if current_depth > max_depth or url in self.visited_urls:
            return
        
        self.visited_urls.add(url)
        
        try:
            response = self.session.get(url, timeout=self.timeout)
            soup = BeautifulSoup(response.content, 'html.parser')
            
            # Find all links
            for link in soup.find_all('a', href=True):
                absolute_url = urljoin(url, link['href'])
                if self.is_valid_url(absolute_url):
                    self.crawl(absolute_url, max_depth, current_depth + 1)
        
        except Exception as e:
            print(f"Error crawling {url}: {e}")
    
    def is_valid_url(self, url):
        """Check if URL belongs to target domain"""
        parsed = urlparse(url)
        target_parsed = urlparse(self.target_url)
        return parsed.netloc == target_parsed.netloc
    
    def test_sql_injection(self, url):
        """Basic SQL injection testing"""
        payloads = [
            "' OR '1'='1",
            "1' OR '1'='1' --",
            "admin'--",
            "' OR 1=1--"
        ]
        
        vulnerabilities = []
        
        for payload in payloads:
            test_url = f"{url}?id={payload}"
            try:
                response = self.session.get(test_url, timeout=self.timeout)
                if self.detect_sqli_error(response.text):
                    vulnerabilities.append({
                        'url': test_url,
                        'payload': payload,
                        'type': 'SQL Injection'
                    })
            except Exception as e:
                continue
        
        return vulnerabilities
    
    def detect_sqli_error(self, response_text):
        """Detect SQL error messages"""
        error_messages = [
            "mysql_fetch",
            "SQL syntax",
            "ORA-",
            "PostgreSQL",
            "Microsoft SQL"
        ]
        return any(error in response_text for error in error_messages)
    
    def test_xss(self, url):
        """Basic XSS testing"""
        payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')"
        ]
        
        vulnerabilities = []
        
        for payload in payloads:
            test_url = f"{url}?search={payload}"
            try:
                response = self.session.get(test_url, timeout=self.timeout)
                if payload in response.text:
                    vulnerabilities.append({
                        'url': test_url,
                        'payload': payload,
                        'type': 'XSS (Reflected)'
                    })
            except Exception as e:
                continue
        
        return vulnerabilities
```

### 3. Logger and Reporter
```python
# utils/logger.py
import logging
import json
from datetime import datetime

class PentestLogger:
    def __init__(self, log_file="pentest.log", report_file="report.json"):
        self.log_file = log_file
        self.report_file = report_file
        self.findings = []
        
        # Setup logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def log_finding(self, severity, category, description, details=None):
        """Log a security finding"""
        finding = {
            'timestamp': datetime.now().isoformat(),
            'severity': severity,
            'category': category,
            'description': description,
            'details': details or {}
        }
        
        self.findings.append(finding)
        self.logger.info(f"[{severity}] {category}: {description}")
    
    def generate_report(self):
        """Generate JSON report"""
        report = {
            'generated_at': datetime.now().isoformat(),
            'total_findings': len(self.findings),
            'findings': self.findings,
            'summary': self._generate_summary()
        }
        
        with open(self.report_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        self.logger.info(f"Report generated: {self.report_file}")
        return report
    
    def _generate_summary(self):
        """Generate findings summary"""
        severity_counts = {}
        for finding in self.findings:
            severity = finding['severity']
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
        
        return severity_counts
```

### 4. Main Application
```python
# main.py
import argparse
from core.network import NetworkScanner
from core.web import WebScanner
from utils.logger import PentestLogger

def main():
    parser = argparse.ArgumentParser(description="Custom Penetration Testing Toolkit")
    parser.add_argument('-t', '--target', required=True, help='Target IP or URL')
    parser.add_argument('-m', '--mode', choices=['network', 'web', 'full'], 
                       default='full', help='Scan mode')
    parser.add_argument('-p', '--ports', default='1-1000', 
                       help='Port range for network scan')
    parser.add_argument('-o', '--output', default='report.json', 
                       help='Output report file')
    
    args = parser.parse_args()
    
    logger = PentestLogger(report_file=args.output)
    logger.logger.info(f"Starting scan on {args.target}")
    
    # Network scanning
    if args.mode in ['network', 'full']:
        logger.logger.info("Starting network scan...")
        scanner = NetworkScanner()
        
        # Parse port range
        start, end = map(int, args.ports.split('-'))
        ports = range(start, end + 1)
        
        results = scanner.scan_ports(args.target, ports)
        
        if results['open_ports']:
            logger.log_finding(
                severity='INFO',
                category='Open Ports',
                description=f"Found {len(results['open_ports'])} open ports",
                details={'ports': results['open_ports']}
            )
            
            # Service detection on open ports
            for port in results['open_ports']:
                service = scanner.detect_service(args.target, port)
                logger.log_finding(
                    severity='INFO',
                    category='Service Detection',
                    description=f"Port {port}: {service}",
                    details={'port': port, 'service': service}
                )
    
    # Web scanning
    if args.mode in ['web', 'full']:
        logger.logger.info("Starting web scan...")
        web_scanner = WebScanner(args.target)
        
        # Crawl website
        logger.logger.info("Crawling website...")
        web_scanner.crawl(args.target, max_depth=2)
        logger.logger.info(f"Discovered {len(web_scanner.visited_urls)} URLs")
        
        # Test for vulnerabilities
        for url in web_scanner.visited_urls:
            # SQL Injection test
            sqli_vulns = web_scanner.test_sql_injection(url)
            for vuln in sqli_vulns:
                logger.log_finding(
                    severity='HIGH',
                    category='SQL Injection',
                    description=f"Potential SQL injection found",
                    details=vuln
                )
            
            # XSS test
            xss_vulns = web_scanner.test_xss(url)
            for vuln in xss_vulns:
                logger.log_finding(
                    severity='MEDIUM',
                    category='Cross-Site Scripting',
                    description=f"Potential XSS vulnerability found",
                    details=vuln
                )
    
    # Generate report
    logger.logger.info("Generating report...")
    report = logger.generate_report()
    logger.logger.info(f"Scan complete. Found {report['total_findings']} findings.")
    
    print("\n" + "="*50)
    print("SCAN SUMMARY")
    print("="*50)
    for severity, count in report['summary'].items():
        print(f"{severity}: {count}")
    print("="*50)

if __name__ == "__main__":
    main()